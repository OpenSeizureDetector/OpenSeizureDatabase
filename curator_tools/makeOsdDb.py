#!/usr/bin/env python3
"""
makeOsdDb.py
This script downloads osdDb data from the remote server using the webAPI.
It then determines the unique events in the data before creating a
JSON file which contains the unique events along with the associated
datapoints.
It adds some metadata to the event records by extracting information from
one of the datapoint records to make it easier for users to assess
events.
The event records contain the following fields:
dataJSON: JSON Encoded string of seizure detector settings and metadata
dataTime: strin representatin of the Date/Time of the event (yyyy-mm-ddThh:mm:ssZ)
datapoints: JSON array of data point objects.
desc: User provided string description of the event.
id: Event ID number.
osdAlarmState:  The highest alarm state generated by OpenSeizureDetector during the event.
subType: event sub-type string
type: event type string
userId: user ID of the user who created the event.

Graham Jones 2022


Licence: GPL v3 or later.

"""
import sys
import os
import argparse
import pandas as pd
import json
import tabulate

# Make the libosd folder accessible in the search path.
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
import libosd.webApiConnection
import libosd.osdDbConnection
import libosd.configUtils

import libosd.tidy_db

def extractJsonVal(row, elem, debug=False):
    """Extract the value of element 'elem' from the JSON string
    in the 'dataJSON' element of dictionary 'row', and return the value,
    or None on error.
    """
    if (debug): print("extractJsonVal(): row=",row)
    dataJSON = row['dataJSON']
    if (dataJSON is not None):
        if (debug): print("extractJsonVal(): dataJSON=",dataJSON,
                          "length=",len(dataJSON))
    else:
        if (debug): print("extractJsonVal(): dataJSON is None")
    if (dataJSON is not None and dataJSON != ''):
        if (debug): print("extractJsonVal(): dataJSON=",dataJSON)
        dataObj = json.loads(dataJSON)
        if (elem in dataObj.keys()):
            elemVal = dataObj[elem]
        else:
            elemVal = None
    else:
        elemVal = None
    return(elemVal)


def getUniqueEventsListsFromServer(configFname="osdb.cfg",
                         outFile="listEvents",
                         start=None,
                         end=None,
                         outDir='.',
                         debug=False):
    """
    Obtain a list of all of the events in the data sharing database.
    Group them by userId and time so that all events within a given
    time period are assumed to be part of the same event to avoid
    duplication.
    Returns a tuple containing lists of unique EventIDs for:
      - all Seizures,
      - tonic clonic seizues,
      - false alarms,
      - unknown events,
      - falls.
      - NDA events (normal daily activities)

    Parameters:
    configFname - filename of JSON configuration file (default osdb.cfg)
    outFile - root of output filename for all files.
    start - None or date from which to extract data in dd/mm/yyyy format.
    debug - print debugging information to console.
    """
    # Create empty dataframes for the different classes of events
    allUniqueEventsDf = pd.DataFrame()
    tcUniqueEventsDf = pd.DataFrame()
    allSeizureUniqueEventsDf = pd.DataFrame()
    falseAlarmUniqueEventsDf = pd.DataFrame()
    unknownUniqueEventsDf = pd.DataFrame()
    fallUniqueEventsDf = pd.DataFrame()
    ndaUniqueEventsDf = pd.DataFrame()

    cfgObj = libosd.configUtils.loadConfig(configFname)
    osd = libosd.webApiConnection.WebApiConnection(cfg=cfgObj['credentialsFname'],
                                                   download=True,
                                                   debug=debug)
    eventLst = osd.getEvents(userId=None, includeDatapoints=False)
    print("Loaded %d Raw Events" % len(eventLst))

    # In this section we try to produce a list of unique events.
    # We select all events that are either
    #    - marked as a seizure
    #    - not an OSD warning (because we don't consisder warnings false alarms
    #    - does not include the word 'test' in the description.
    #    - is not included in the 'invalidEvents' list in the
    #            configuration file.
    # We then group them by user ID and by time - all events within a 10 minute period are
    #  considered a single event rather than multiple seizures or false alarms.
    # We then select the 'best' event from within the group and add that to the list.  The
    #   'best' event is the first one that
    #    - is a manual alarm
    #    - contains a text description
    #    - is an OSD generated alarm.

    # Read the event list into a pandas data frame.
    df = pd.read_json(json.dumps(eventLst))
    df['dataTime'] = pd.to_datetime(df['dataTime'])
    # Add some extra metadata to the event records.
    df['phoneAppVersion'] = df.apply(lambda row: extractJsonVal(row,'phoneAppVersion', debug=False), axis = 1)
    df['dataSource'] = df.apply(lambda row: extractJsonVal(row,'dataSourceName', debug=False), axis = 1)
    df['watchAppVersion'] = df.apply(lambda row: extractJsonVal(row,'watchSdVersion', debug=False), axis = 1)
    # drop the dataJSON column because we do not need it.
    df=df.drop('dataJSON', axis=1)

    # Filter out warnings (unless they are tagged as a seizure) and tests.
    if not cfgObj['includeWarnings']:
        print("Filtering out warnings (unless they are associated with a seizure or a fall event)")
        df=df.query("type=='Seizure' or type=='Fall' or osdAlarmState!=1")

    # Filter by date
    if (start is not None):
        startDateTime = pd.to_datetime(start, utc=True)
        dateQueryStr = 'dataTime >= "%s"' % startDateTime
        print("Applying Date Query: %s" % dateQueryStr)
        df = df.query(dateQueryStr)

    # Filter by end date
    if (end is not None):
        endDateTime = pd.to_datetime(end, utc=True)
        dateQueryStr = 'dataTime <= "%s"' % endDateTime
        print("Applying Date Query: %s" % dateQueryStr)
        df = df.query(dateQueryStr)

        
    # Filter out 'Test' data
    print("Filtering out events described as 'test'")
    df=df.query("not(desc.str.lower().str.contains('test'))")

        
    #
    # This is to set the print order when we print the data frames
    columnList = ['id', 'userId',
                  'dataTime', 'type',
                  'subType', 'osdAlarmState',
                  'dataSource', 'phoneAppVersion', 'watchAppVersion',
                  'desc']

    # Group the data by userID and time period
    print("Grouping into periods of %s" % cfgObj['groupingPeriod'])
    groupedDf=df.groupby(['userId','type',pd.Grouper(
        key='dataTime',
        freq=cfgObj['groupingPeriod'])])

    # Loop through the grouped data
    for groupParts, group in groupedDf:
        userId, eventType, dataTime = groupParts
        if (debug): print()
        if (debug): print("Starting New Group....")
        #print("UserId=%d, type=%s, dataTime=%s" % (userId, eventType,
        #                                           dataTime.strftime('%Y-%m-%d %H:%M:%S')))
        if (debug): print("Selecting ALARM rows")
        alarmRows=group[group.osdAlarmState==2]
        if len(alarmRows.index)>0:
            if (debug): print("alarmRows:")
            #print(alarmRows[columnList])
            outputRows = alarmRows
        else:
            if (debug): print("No alarm rows - selecting tagged rows")
                    # non-zero length description
            taggedRows=group[group.desc.str.len()>0]
            # description is not 'null'
            taggedRows=taggedRows[~taggedRows.desc.str.contains("null")]
            if len(taggedRows.index)>0:
                if (debug): print("Tagged Rows:")
                #print(taggedRows[columnList])
                outputRows = taggedRows
            else:
                if (debug): print("No Tagged Rows")
                outputRows = group

        # Pick the first recordon the grounds that the user is most likely
        # to have put most effort into describing that.
        #outputIndex = int(len(outputRows.index)/2)
        outputIndex = 0
        #print("len(outputRows)=%d, outputIndex=%d" % (len(outputRows), outputIndex))
        if (debug): print("UniqueEvent=")
        eventRow = outputRows.iloc[[outputIndex]]
        if (debug): print(eventRow[columnList])
        #allUniqueEventsDf = allUniqueEventsDf.append(eventRow)
        allUniqueEventsDf = pd.concat((allUniqueEventsDf, eventRow))


        if eventRow['type'].str.contains('Seizure').any():
            #allSeizureUniqueEventsDf = allSeizureUniqueEventsDf.append(eventRow)
            allSeizureUniqueEventsDf = pd.concat((allSeizureUniqueEventsDf, eventRow))
        if eventRow['subType'].str.contains('Tonic-Clonic').any():
            #tcUniqueEventsDf = tcUniqueEventsDf.append(eventRow)
            tcUniqueEventsDf = pd.concat((tcUniqueEventsDf, eventRow))
        if eventRow['type'].str.contains('False Alarm').any():
            #falseAlarmUniqueEventsDf = falseAlarmUniqueEventsDf.append(eventRow)
            falseAlarmUniqueEventsDf = pd.concat((falseAlarmUniqueEventsDf, eventRow))
        if eventRow['type'].str.contains('Unknown').any():
            #unknownUniqueEventsDf = unknownUniqueEventsDf.append(eventRow)
            unknownUniqueEventsDf = pd.concat((unknownUniqueEventsDf, eventRow))
        if eventRow['type'].str.contains('Fall').any():
            #fallUniqueEventsDf = fallUniqueEventsDf.append(eventRow)
            fallUniqueEventsDf = pd.concat((fallUniqueEventsDf, eventRow))
        if eventRow['type'].str.contains('nda').any():
            ndaUniqueEventsDf = pd.concat((ndaUniqueEventsDf, eventRow))

    print("Number of Unique Events = %d" % len(allUniqueEventsDf.index))
    #print(tabulate(df, headers='keys', tablefmt='fancy_grid'))
    if (debug): print(tabulate.tabulate(allUniqueEventsDf[columnList], headers=columnList, tablefmt='fancy_grid'))

    if (debug): print()
    if (debug): print("Unique Unknown Events (%d):" % len(unknownUniqueEventsDf.index))
    if (debug): print(tabulate.tabulate(unknownUniqueEventsDf[columnList], headers=columnList, tablefmt='fancy_grid'))


    if (debug): print()
    if (debug): print("Unique False Alarm Events (%d):" % len(falseAlarmUniqueEventsDf.index))
    if (debug): print(tabulate.tabulate(falseAlarmUniqueEventsDf[columnList], headers=columnList, tablefmt='fancy_grid'))


    if (debug): print()
    if (debug): print("Unique Seizure Events (%d):" % len(allSeizureUniqueEventsDf.index))
    if (debug): print(tabulate.tabulate(allSeizureUniqueEventsDf[columnList], headers=columnList, tablefmt='fancy_grid'))

    if (debug): print()
    if (debug): print("Unique TC Seizure Events (%d):" % len(tcUniqueEventsDf.index))
    if (debug): print(tabulate.tabulate(tcUniqueEventsDf[columnList], headers=columnList, tablefmt='fancy_grid'))

    if (debug): print()
    if (debug): print("Unique NDA Events (%d):" % len(ndaUniqueEventsDf.index))
    if (debug): print(tabulate.tabulate(ndaUniqueEventsDf[columnList], headers=columnList, tablefmt='fancy_grid'))

    retLst = []
    if len(allSeizureUniqueEventsDf)>0:
        #fname = "%s_%s_allSeizures.csv" % (outFile, cfgObj['groupingPeriod'])
        #allSeizureUniqueEventsDf.to_csv(os.path.join(outDir,fname), index=False, columns=columnList)
        #print("All Seizure Events saved as %s" % fname)
        retLst.append(allSeizureUniqueEventsDf['id'].tolist())
    else:
        print("No Seizures in period")
        retLst.append(None)

    if len(tcUniqueEventsDf)>0:
        retLst.append(tcUniqueEventsDf['id'].tolist())
    else:
        print("No Tonic Clonic Seizures in period")
        retLst.append(None)

    if len(falseAlarmUniqueEventsDf)>0:
        retLst.append(falseAlarmUniqueEventsDf['id'].tolist())
    else:
        print("No False Alarm Events in period")
        retLst.append(None)

    if len(unknownUniqueEventsDf)>0:
        retLst.append(unknownUniqueEventsDf['id'].tolist())
    else:
        print("No Unknown Events in period")
        retLst.append(None)

    if len(fallUniqueEventsDf)>0:
        retLst.append(fallUniqueEventsDf['id'].tolist())
    else:
        print("No Fall Events in period")
        retLst.append(None)

    if len(ndaUniqueEventsDf)>0:
        retLst.append(ndaUniqueEventsDf['id'].tolist())
    else:
        print("No NDA Events in period")
        retLst.append(None)

    return(retLst)


def getEventsFromList(eventsLst, configFname="client.cfg",
                      includeDatapoints=True, download=True, tidy=True, debug=False):
    """ Download the data for the evenst in evenstLst, returning a list of
    event Objects.
    """

    eventsObjLst = []
    if (eventsLst is None):
        print("EventsLst empty - not downloading anything!")
        return eventsObjLst
    
    cfgObj = libosd.configUtils.loadConfig(configFname)
    osd = libosd.webApiConnection.WebApiConnection(cfg=cfgObj['credentialsFname'],
                                                   download=download,
                                                   debug=debug)
    eventsObjLst = []
    
    for eventId in eventsLst:
        if (eventId in cfgObj['invalidEvents']):
            print("event %s marked as invalid in config file - ignoring" % eventId)
        else:
            try:
                print("Retrieving eventId %d" % eventId)
                eventObj = osd.getEvent(eventId,
                                        includeDatapoints=includeDatapoints)
                eventsObjLst.append(eventObj)
            except:
                print("Error downloading Event - stopping - re-run makeOsdDb to re-start")
                break
    if (tidy):
        print("Tidying retrieved data....")
        libosd.tidy_db.tidyDbObj(cfgObj, eventsObjLst, debug)

    return eventsObjLst


def getNewEventsIdsLst(eventsLst, osd, configfname, debug=False):
    ''' Return a list of new events that are available in eventsLst which are not
    in the existing osdDbConnection osd.
    '''
    cfgObj = libosd.configUtils.loadConfig(configfname)

    osdEventIdsLst = osd.getEventIds()
    newEventsIdsLst = []

    if (eventsLst is not None):
        for eventId in eventsLst:
            if not eventId in osdEventIdsLst:
                if not eventId in cfgObj['invalidEvents']:
                    newEventsIdsLst.append(eventId)
                else:
                    if debug: print("Skipping Invalid Event %s" % eventId)
    if (debug): print("New Event Ids = ", newEventsIdsLst)
    return newEventsIdsLst
            

def validateDb(osd, minDp = 1, update=False):
    """
    Check each event in database osd, and remove any events that have less than minDp datapoints.
    """
    outfname = "invalidEvents.txt"
    outfile = open(outfname,"a")
    eventsLst = osd.getAllEvents()
    startLen = len(eventsLst)
    for eventObj in eventsLst:
        if not 'datapoints' in eventObj:
            print("Event %s does not contain datapoints" % eventObj['id'])
            if (update): eventsLst.remove(eventObj)
            outfile.write("%s, " % eventObj['id'])
        else:
            if len(eventObj['datapoints']) < minDp:
                print("Event %s has insufficient datapoints (%d)" % (eventObj['id'], len(eventObj['datapoints'])))
                if (update): eventsLst.remove(eventObj)
                outfile.write("%s, " % eventObj['id'])
    outfile.write("\n")
    outfile.close()
    endLen = len(eventsLst)
    print("validateDb() - startLen=%d, endLen=%d, osdLen=%d" % (startLen, endLen, len(osd.getAllEvents())))
    print("invalid events written to file %s" % outfname)

def updateOsdbFile(fname, eventsLst, configfname, debug=False):
    '''
    Update the specified file from the osdb cache directory by retrieving the events which
    are not in the file from the server and adding them into the file.
    EventsLst should be the list of events that are available on the server.
    Applies data tidying and validation before saving.
    '''
    cfgObj = libosd.configUtils.loadConfig(configfname)
    osdb = libosd.osdDbConnection.OsdDbConnection(debug=debug, cacheDir=cfgObj['osdbDir'])
    nOsd = osdb.loadDbFile(fname)
    osdb.removeEvents(cfgObj['invalidEvents'])
    # See which of the events in eventsLst are new, and not already in the osdb File.
    newEventsLst = getNewEventsIdsLst(eventsLst, osdb, configfname, debug=debug)
    print("newEventsLst = ", newEventsLst)
    # Download the new events data
    newEventsObjLst = getEventsFromList(newEventsLst, configfname)
    # Add the new events data into the osdb instance
    print("Adding new events to OSDB data")
    osdb.addEvents(newEventsObjLst)
    print("Updating Seizure Start/End Times")
    libosd.tidy_db.updateDBSeizureTimes(cfgObj, osdb.getAllEvents(), debug)
    print("Validating db")
    validateDb(osdb, minDp=1, update=True)
    print("Saving file to file name: %s" % fname)
    osdb.saveDbFile(fname, useCacheDir=True)

    fnameRoot = os.path.splitext(fname)[0]
    indexFname = "%s.csv" % fnameRoot
    print("Index Filename = %s" % indexFname)
    print("Saving Index to %s" % indexFname)
    osdb.saveIndexFile(indexFname, useCacheDir=True)
    

def saveEventsAsJson(eventsLst, fname, configFname,
                     debug=False):
    """
    Given a list of event IDs (EventsLst), retrieve the data for the event
    from the database, and save it as a JSON encoded string to file name
    fname.
    This is used when creating a new osdb file, rather than updating an existing one.
    """
    eventsObjLst = getEventsFromList(eventsLst,
                                       configFname=configFname,
                                       includeDatapoints=True,
                                       download=True,
                                       debug=debug)
    if (debug): print(eventsObjLst)

    f = open(fname,'w')
    json.dump(eventsObjLst,f, indent=2, sort_keys=True)
    f.close()
    print("Wrote events data to %s" % fname)

    return(True)


if (__name__=="__main__"):
    print("makeOsdDb.py.main()")
    parser = argparse.ArgumentParser(description='Create an anonymised database of unique seizure-like events for distribution')
    parser.add_argument('--config', default="osdb.cfg",
                        help='name of json file containing configuration information and login credientials - see osdb.cfg.template')
    parser.add_argument('--start', default=None,
                        help="Start date for saving data (yyyy-mm-dd format).  Data before this date is not extracted from the database")
    parser.add_argument('--end', default=None,
                        help="End date for saving data (yyyy-mm-dd format).  Data after this date is not extracted from the database")
    parser.add_argument('--create', action='store_true',
                        help="Create a new set of local JSON files, rather than updating the existing intalled osdb files.")
    parser.add_argument('--debug', action='store_true',
                        help="Write debugging information to screen")
    parser.add_argument('--out', default="osdb",
                        help='root of output filenames')
    
    argsNamespace = parser.parse_args()
    args = vars(argsNamespace)
    print(args)

    cfgObj = libosd.configUtils.loadConfig(args['config'])
    print(cfgObj)


    outDir = "."
    if not args['create']:
        outDir = cfgObj['osdbDir']
    (seizureEventsLst, tcEventsLst,
     falseAlarmEventsLst, unknownEventsLst, fallEventsLst, ndaEventsLst) \
     = getUniqueEventsListsFromServer(args['config'],
                            outFile=args['out'],
                            start=args['start'],
                            end=args['end'],
                            outDir=outDir,
                            debug=args['debug'])

    if (args['debug']): print(tcEventsLst)

    if (args['create']):
        fname = "%s_%s_tcSeizures.json" % (args['out'], cfgObj['groupingPeriod'])
        saveEventsAsJson(tcEventsLst,
                         fname,
                         args['config'],
                         debug=args['debug'])
        print("Tonic Clonic Seizure Events Saved to %s" % fname)

        fname = "%s_%s_allSeizures.json" % (args['out'], cfgObj['groupingPeriod'])
        saveEventsAsJson(seizureEventsLst,
                         fname, 
                         args['config'],
                         debug=args['debug'])
        print("All Seizure Events Saved to %s" % fname)

        fname = "%s_%s_fallEvents.json" % (args['out'], cfgObj['groupingPeriod'])
        saveEventsAsJson(fallEventsLst,
                         fname,
                         args['config'],
                         debug=args['debug'])
        print("Fall Events Saved to %s" % fname)

        fname = "%s_%s_ndaEvents.json" % (args['out'], cfgObj['groupingPeriod'])
        saveEventsAsJson(ndaEventsLst,
                         fname,
                         args['config'],
                         debug=args['debug'])
        print("NDA Events Saved to %s" % fname)



        fname = "%s_%s_falseAlarms.json" % (args['out'], cfgObj['groupingPeriod'])
        saveEventsAsJson(falseAlarmEventsLst,
                         fname,
                         args['config'],
                         debug=args['debug'])
        print("False Alarm Events Saved to %s" % fname)

        #fname = "%s_%s_unknownEvents.json" % (args['out'], cfgObj['groupingPeriod'])
        #saveEventsAsJson(unknownEventsLst,
        #                 fname,
        #                 args['config'],
        #                 debug=args['debug'])
        #print("Unknown Events Saved to %s" % fname)
    
    else:   # Create is false, so we update an existing osdb installation.
        fname = "%s_%s_tcSeizures.json" % (args['out'], cfgObj['groupingPeriod'])
        print("")
        print("Updating Tonic Clonic Seizures database file %s" % fname)
        updateOsdbFile(fname, tcEventsLst,  args['config'], args['debug'])

        fname = "%s_%s_allSeizures.json" % (args['out'], cfgObj['groupingPeriod'])
        print("")
        print("Updating All Seizures database file %s" % fname)
        updateOsdbFile(fname, seizureEventsLst,  args['config'], args['debug'])

        fname = "%s_%s_fallEvents.json" % (args['out'], cfgObj['groupingPeriod'])
        print("")
        print("Updating Fall Events database file %s" % fname)
        updateOsdbFile(fname, fallEventsLst,  args['config'], args['debug'])

        fname = "%s_%s_ndaEvents.json" % (args['out'], cfgObj['groupingPeriod'])
        print("")
        print("Updating NDA Events database file %s" % fname)
        updateOsdbFile(fname, ndaEventsLst,  args['config'], args['debug'])
        
        fname = "%s_%s_falseAlarms.json" % (args['out'], cfgObj['groupingPeriod'])
        print("")
        print("Updating False Alarm Events database file %s" % fname)
        updateOsdbFile(fname, falseAlarmEventsLst,  args['config'], args['debug'])

        #fname = "%s_%s_unknownEvents.json" % (args['out'], cfgObj['groupingPeriod'])
        #print("")
        #print("Updating Unknown Events database file %s" % fname)
        #updateOsdbFile(fname, unknownEventsLst,  args['config'], args['debug'])

